# 운영체제의 큰 그림



- 운영체제는 특별한 프로그램입니다.
- 윈도우, macOS, 리눅스, iOS, 안드로이드 등 다양한 종류의 운영체제가 존재하지만, 종류와 관계없이 공통적으로 제공하는 핵심 기능은 유사합니다.

<img width="440" alt="image" src="https://github.com/user-attachments/assets/6da67dc4-be44-4dd2-89a9-f87f81f70619" />


- 운영체제의 핵심 기능을 담당하는 부분을 `커널(Kernel)` 이라고 하며, 일반적으로 ‘운영체제’라는 용어는 이 커널을 지칭한다고 볼 수 있습니다.
- 운영체제는 크게 두 가지 핵심 기능을 제공합니다:
    1. 자원 할당 및 관리
    2. 프로세스 및 스레드 관리
    - 이 두 기능을 통해 프로그램들은 운영체제가 제공하는 다양한 기능을 사용할 수 있습니다.

<img width="367" alt="image" src="https://github.com/user-attachments/assets/8b5f7655-4b74-4e67-88bf-f1870625ed66" />


<img width="375" alt="image" src="https://github.com/user-attachments/assets/23d0ad9c-9a86-4363-a1e3-ac6754fa387f" />


# 운영체제의 역할



## 자원

- 운영체제가 관리하는 자원은 시스템 자원이라 불리며, 프로그램 실행에 필요한 요소들을 의미합니다.
    - 실행에 필요한 데이터 → `소프트웨어 자원`
    - 실행에 필요한 부품(CPU, 메모리 등) → `하드웨어 자원`
- 운영체제는 사용자 응용 프로그램이 직접 컴퓨터 부품에 접근하지 않도록, 대신하여 자원에 접근하고 효율적으로 관리합니다.

## CPU 관리 : CPU 스케줄링

- 메모리에는 동시에 여러 프로그램이 적재되지만, CPU는 이들 모두 동시에 수행할 수 없는 한정된 자원입니다.
    - 실행 중인 프로그램들은 CPU를 사용하기 위해 서로 기다려야 하며,
    - 운영체제는 모든 프로그램들이 공정하게 CPU를 할당받도록 CPU 스케줄링을 수행합니다.
- `CPU 스케줄링` : 실행 중인 프로그램들에 대한 CPU의 할당 순서와 시간을 결정하는 작업

## 메모리 관리 : 가상 메모리

- 운영체제는 새롭게 실행하는 프로그램을 메모리에 적재하고, 종료된 프로그램은 메모리에서 제거하며, 메모리 공간을 낭비 없이 효율적으로 관리해야 합니다.
- 이를 위해 `가상 메모리` 기술을 활용합니다.
    - `가상 메모리`: 실제 물리적인 메모리보다 더 큰 메모리를 사용할 수 있도록 해주는 운영체제의 메모리 관리 기법
- 이 기술을 통해 프로그램은 실제 메모리보다 큰 주소 공간을 사용하는 것처럼 동작할 수 있습니다.

## 파일/디렉터리 관리 : 파일 시스템

- 보조기억장치는 메모리보다 훨씬 큰 용량을 가지므로 체계적으로 관리되어야 합니다.
- `파일 시스템` : 보조기억장치 내의 데이터를 파일과 폴더(디렉터리) 단위로 관리할 수 있게 해주는 운영체제의 내부 프로그램
- 이 시스템이 없으면 어질러진 서랍처럼 데이터를 찾기 어려워집니다. 파일 시스템은 데이터를 체계적으로 관리하여 효율적 접근을 가능하게 합니다.

## 기타 자원 관리 – 입출력장치와 캐시 메모리

- 운영체제는 입출력장치와 캐시 메모리도 함께 관리합니다.
    - 장치 드라이버 및 하드웨어 인터럽트 서비스 루틴 제공
    - 캐시 메모리의 일관성 유지

## 프로세스 및 스레드 관리

- ‘실행 중인 프로그램’을 운영체제에서는 `프로세스(Process)` 라고 부릅니다.
- 그리고 프로세스 내에서 실제 작업을 수행하는 실행 단위를 `스레드(Thread)` 라고 합니다.
    - 여러 프로세스가 동시에 메모리에 적재될 수 있으며, 운영체제는 이들 각각에 필요한 자원을 할당
    - 스레드는 프로세스가 할당받은 자원을 이용해 작업 수행
    - 스레드가 여러 개인 경우, 동일한 작업을 병렬로 처리할 수 있음
- 운영체제는 다수의 프로세스 및 스레드가 동시에 실행되면서 발생할 수 있는 문제를 제어하고, 자원을 적절히 배분해야 합니다.

<img width="561" alt="image" src="https://github.com/user-attachments/assets/ce900e57-ec90-4eda-a754-f18db090e562" />


# 시스템 콜과 이중 모드



- 운영체제(일종의 프로그램)는 커널 영역에 적재되며, 사용자 프로그램은 사용자 영역에 적재되어 실행됩니다.
    - `커널 영역(Kernel Space)`: 운영체제 코드가 실행되는 공간
    - `사용자 영역(User Space)`: 일반 응용 프로그램이 실행되는 공간
- 운영체제의 기능은 커널 영역에 위치하기 때문에, 응용 프로그램은 직접 자원에 접근하거나 조작할 수 없습니다.
- 대신, 운영체제가 대신 자원 접근 및 조작을 수행합니다.
    
    <img width="263" alt="image" src="https://github.com/user-attachments/assets/acc259d5-807f-4772-83c5-f908288396e1" />


    

<img width="632" alt="image" src="https://github.com/user-attachments/assets/602d8cc7-c846-44f7-8cd6-1f5d1a0dca2b" />


## 시스템 콜 (System Call)

- 응용 프로그램이 운영체제의 기능을 사용하기 위해 호출하는 함수 형태의 인터페이스입니다.
    - 시스템 콜을 호출하면, CPU는 사용자 모드에서 커널 모드로 전환되어 커널 코드를 실행합니다.
    - 시스템 콜은 소프트웨어 인터럽트의 일종으로, 입출력 명령어와 같은 특수 명령에 의해 트리거됩니다.

<img width="524" alt="image" src="https://github.com/user-attachments/assets/b48b18bc-cac0-4298-a320-107871cc4676" />

<img width="588" alt="image" src="https://github.com/user-attachments/assets/4d23edd1-701a-473c-9d27-8a2df2c2db0a" />


## 시스템 콜의 실행 절차

1. 사용자 영역에서 시스템 콜 호출
2. 소프트웨어 인터럽트 발생
3. CPU는 현재 상태를 저장하고 커널 모드 진입
4. 커널 영역 내 시스템 콜 코드 실행
5. 사용자 모드로 복귀하여 이후 코드 실행
- 이 과정을 통해 응용 프로그램은 자원에 간접 접근할 수 있습니다.

<img width="690" alt="image" src="https://github.com/user-attachments/assets/fe008852-9a19-416c-a50b-13624c5516d4" />


## 이중 모드

- CPU는 명령어를 실행할 때 사용자 모드와 커널 모드를 구분하여 작동합니다.
    - `사용자 모드` : 응용 프로그램 코드 실행. 자원 접근 불가. 운영체제 기능 호출 불가.
    - `커널 모드` : 운영체제 코드 실행. 모든 자원 접근 및 명령어 실행 가능.
    - 시스템 보안을 위해, 자원 접근은 반드시 커널 모드에서만 가능하도록 설계
    
    > 현재 CPU의 모드는 플래그 레지스터의 슈퍼바이저 플래그를 통해 확인 가능
    > 

### cf) 프로세스의 계층 구조

- 운영체제는 fork() 시스템 콜을 통해 새로운 프로세스를 생성할 수 있습니다.
    - 프로세스는 다른 프로세스를 생성할 수 있고,
    - 생성한 프로세스를 자식 프로세스, 생성한 쪽을 부모 프로세스라 부릅니다.
    - 이런 구조를 통해 계층적으로 프로세스를 관리할 수 있습니다.
    
    <img width="494" alt="image" src="https://github.com/user-attachments/assets/b6c857ad-af2a-4d33-b12a-152c619573e7" />

    

### cf) 시스템 콜 분석

- `strace` : 리눅스 환경에서 프로그램이 호출하는 시스템 콜을 추적할 수 있는 도구
    - 간단한 문자열 출력 프로그램도 600회 이상 시스템 콜 호출
    - `ls` 명령어 같은 간단한 명령도 내부적으로 수많은 시스템 콜 수행

<img width="474" alt="image" src="https://github.com/user-attachments/assets/7eddad63-a5d0-4d8d-b1fc-227393f317fa" />
